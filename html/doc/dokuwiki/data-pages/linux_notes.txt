

# How to Use Linux - Notes


# Boot

Hold down while booting

F2  open UEFI settings

Alt+F10 reset PC


# Terminal

Copy and Paste in terminal: ctrl+shift+C, ctrl+shift+V

See Terminal - preferences - shortcuts


# User space boot

GUI - settings - about, shows Gnome version 3.36.3

How is gnome started at startup?  How can it be optional?  GRUB, rcconf, lightdm

[https://askubuntu.com/questions/378046/how-to-run-ubuntu-xubuntu-in-a-complete-non-gui-mode](https://askubuntu.com/questions/378046/how-to-run-ubuntu-xubuntu-in-a-complete-non-gui-mode)


# Install software

How to install brave for linux.

[https://brave.com/linux/](https://brave.com/linux/)


# Gnome

Modifications to gnome 3.36,3

Remove home and trash icons from desktop.  They show up in nautilus file explorer.

$ gsettings set org.gnome.shell.extensions.desktop-icons show-trash false

$ gsettings set org.gnome.shell.extensions.desktop-icons show-home false


# Terminal

Terminal, Shell, Console

Session

Tiling splits

Termux, terminal multiplexer


# How to Boot Linux - example judson

For Jetson Nano

Boot to console by default

Optionally boot to graphical

The disable didn't work because the Debian `/etc/X11/default-display-manager` logic is winding up overriding it.

In order to make text boot the default under systemd (regardless of which distro, really):

systemctl set-default multi-user.target

To change back to booting to the GUI,

systemctl set-default graphical.target


# Judson examples

Goals

X boot judson without gui.

X  Start gui on judson at will.

X Shutdown gui on judson at will.

Start python webserver on judson at boot.

X Connect to judson webserver from phone.

Start skateboard program at boot.

Connect to Tello at boot.

Let webmon talk to skateboard.  Can they share data files?

Judson is normally running in multi-user.target, no GUI


```
$ sudo systemctl isolate graphical.target    # open the GUI
$ sudo systemctl isolate multi-user.target   # close the GUI
Ctrl+Alt+F1   # get a tty login screen
```


$ mount /dev/sda1 /media/john    # after plugging in the seagate

Soft links in FHS

/bin -> /usr/bin

/sbin -> /usr/sbin

/lib -> /usr/lib

/lib32 -> /usr/lib32

/lib64 -> /usr/lib64

/libx32 -> /usr/libx32


# systemd


## Boot Targets

$ systemctl get-default   # show boot target

graphical.target

$ systemctl isolate graphical.target   # start a different target right now

$ systemctl set-default graphical.target  # change the boot target

Run Levels

0 system shutdown

1 single user mode, no network, essential services only (maintenance mode)

2 not used

3 multi-user mode

4 not used

5 multi-user mode plus graphical mode login

6 system restart

Run levels are managed by /sbin/init

Run level is defined by a kernel parameter or in the /etc/inittab file.

There are 3 paradigms to manage services in Ubuntu. `System V init`, `upstart` and `systemd`. As of Ubuntu 18.04, it is `systemd`. – [smwikipedia](https://unix.stackexchange.com/users/4061/smwikipedia) [Aug 21 '18 at 6:14](https://unix.stackexchange.com/questions/34405/file-in-ubuntu-equivalent-to-etc-inittab-file-in-redhat#comment844173_34406)

Ubuntu does not use runlevels, nor etc/inittab

SysV init used etc/inittab

In Ubuntu 18, the init binary is soft linked to systemd.


```
$ ls -al /sbin/init
/sbin/init -> /lib/systemd/systemd
```


init, aka sysvinit, as in System 5 init

Upstart, first introduced in Ubuntu 6 in 2006

systemd, adopted in Ubuntu 15


## Userspace Boot

From init, through upstart, to systemd.

For booting, many linux distributions originally used init, aka sysvinit, taken from System V Unix.  Later, many distributions replaced init with upstart, and later still with systemd.

Boot system adoption by distribution release number.


<table>
  <tr>
   <td>
   </td>
   <td>init
   </td>
   <td>upstart
   </td>
   <td>systemd
   </td>
  </tr>
  <tr>
   <td>Debian
   </td>
   <td>
   </td>
   <td>
   </td>
   <td>8
   </td>
  </tr>
  <tr>
   <td>Ubuntu
   </td>
   <td>
   </td>
   <td>6 (2006)
   </td>
   <td>15
   </td>
  </tr>
  <tr>
   <td>Fedora
   </td>
   <td>
   </td>
   <td>9
   </td>
   <td>15
   </td>
  </tr>
  <tr>
   <td>openSUSE
   </td>
   <td>
   </td>
   <td>11
   </td>
   <td>12
   </td>
  </tr>
</table>


Comparison of init and systemd.


<table>
  <tr>
   <td>
   </td>
   <td>init
   </td>
   <td>systemd
   </td>
  </tr>
  <tr>
   <td>binary
   </td>
   <td>/etc/init
   </td>
   <td>/lib/systemd/systemd
   </td>
  </tr>
  <tr>
   <td>states
   </td>
   <td>runlevels 0-6
<p>
1
<p>
3
<p>
5
<p>
4
   </td>
   <td>targets
<p>
rescue.target
<p>
multi-user.target
<p>
graphical.target
<p>
<em>custom</em>.target
   </td>
  </tr>
  <tr>
   <td>config
   </td>
   <td>parameters in /etc/inittab file
   </td>
   <td>script files in /etc/init and /etc/init.d
   </td>
  </tr>
  <tr>
   <td>start daemons
   </td>
   <td>serial
   </td>
   <td>parallel
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>Insert command into /etc/rc.local
   </td>
   <td>
   </td>
  </tr>
</table>


systemd init

Units


## Systemctl

$ sudo systemctl poweroff

$ sudo systemctl reboot

$ sudo systemctl rescue

$ systemctl list-unit-files --type=target   # list all targets

$ systemctl get-default   # show current boot target

$ systemctl list-dependencies multi-user.target   # list unit files tied to a target

$ sudo systemctl set-default multi-user.target   # set target for boot

$ sudo systemctl isolate multi-user.target   # activate target right now


## Journalctl

Location of unit files, in priority order.


```
/lib/systemd/system    # system default
/run/systemd/system   # override
/etc/systemd/system   # override
```



## Start a custom service at boot

Add a command into /etc/rc.local.  That probably still words, but a newer more complicated method is to create a unit file that defines a systemd service.

1. Create a script or executable.


```
$ vi myservice.sh
```


2. Copy the script to /usr/bin/ and make it executable.  (Notice that /bin is soft linked to /usr/bin, which means I will be putting my own service in with the system services.)


```
$ sudo cp myservice.sh /usr/bin/myservice.sh
$ sudo chmod +x /usr/bin/myservice.sh
```


3. Create a unit file to define a systemd service that will manage your script.

[Unit]

Description=Skateboard monitor webservice.

[Service]

Type=simple

ExecStart=/bin//bash /usr/bin/webservice.sh

[Install]

WantedBy=multi-user.target

4.  Copy the unit file to /etc/systemd/system and give it permissions.


```
$ sudo cp myservice.service /etc/systemd/system/myservice.service
$ sudo chmod 644 /etc/systemd/system/myservice.service
```


5. Test the service.

$ sudo systemctl start myservice

$ sudo systemctl status myservice

$ sudo systemctl stop myservice

6.  Enable the service.  (Put it in the boot sequence.)

$ sudo systemctl enable myservice  # put service into boot sequence  


# Folder Structure

Filesystem Hierarchy Standard (FHS)

[https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard)

$ man hier #  show complete list of folders

/ - kernel

/bin - binary executable files

/boot - files used during boot

/dev - hardware devices - not a folder, device and partition names

/etc - configuration files

/tmp - temporary, will be gone at next boot

/usr - duplicate 

/home

/root - for the root user, not /home/root

See more about the /etc folder

[https://www.linuxnix.com/linux-directory-structure-explainedetc-folder/](https://www.linuxnix.com/linux-directory-structure-explainedetc-folder/)

Locations for binary executables and scripts. 

/bin   # in Ubuntu 20, soft link to /usr/bin

/sbin  # in Ubuntu 20, soft link to /usr/sbin

/usr/bin   # 

/usr/sbin  # 

/usr/local/bin  # put my own scripts here

/usr/local/sbin  # put my own root scripts here

sbin - s is for system, for commands that require root privileges

bin - root not required

According to the documentation, /bin and /sbin are for commands that are required before the /usr partition is mounted.  But in Ubuntu 20 on my RacerSwift, they are soft linked to /usr.

The first four - /bin, /sbin, /usr/bin, /usr/sbin - should be populated only by the package manager.  /usr/local/bin and sbin is for files not coming from the package manager.


## Where do executables live?


<table>
  <tr>
   <td><strong>Folder</strong>
   </td>
   <td><strong>Who populates</strong>
   </td>
   <td><strong>Who uses</strong>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>/bin
   </td>
   <td>package manager
   </td>
   <td>any user
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>/sbin
   </td>
   <td>package manager
   </td>
   <td>root
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>/usr/bin
   </td>
   <td>package manager
   </td>
   <td>any user
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>/usr/sbin
   </td>
   <td>package manager
   </td>
   <td>root
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>/usr/local/bin
   </td>
   <td>any user
   </td>
   <td>any user
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>/usr/local/sbin
   </td>
   <td>any user
   </td>
   <td>root
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>/home/me/.local/bin
   </td>
   <td>me
   </td>
   <td>me
   </td>
   <td>
   </td>
  </tr>
</table>


/bin vs /sbin - the s stands for system, used by administrators, require root

/bin and /sbin - for exes called early in the boot, before /usr is mounted

/usr/bin and /usr/sbin - for exes called after /usr is mounted

/usr/local - overrides will not be tampered with during package manager update

Special cases

/lib

/etc/init.d - startup scripts, services

Libraries are also executable?

What are bin, lib, share?

Where do configuration files live?

/etc


# CLI

typewriter = keyboard plus printer.

tele-typewriter = A typewriter operating at a distance.

teletype = tty = abbreviations for tele-typewriter.

The first typewriter printed on single sheets of paper.

Teletype machines and the first printers used a continuous spool of paper.

Modern printers have gone back to single sheets.

console - a teletype used to interact with a computer

terminal - same thing as a console.

shell - 

prompt

chat

webchat

telnet

ssh

Console, Headless.

Picture a server farm with thousands of rack-mounted servers running 24/7 for years on end.

An operator can use ssh to connect to any individual server to monitor and maintain.

Console

Shell



*   sh, Bourne shell, Steve Bourne
*   sh, POSIX shell
*   bash, Bourne Again Shell
*   ksh, Korn shell, 
*   zsh
*   csh, C shell
*   tcsh

Terminal window. Aka terminal emulator or terminal program. A console within a window. Requires a window manager.



*   gnome-terminal
*   konsole
*   xterm
*   rxvt
*   kvt
*   nxterm
*   eterm


# GUI


### 3 layers

1. **X windows**.  aka X11 or X.  Underlying technology for bitmapped display.  Part of the kernel.  Open source.  Originated at MIT in 1984, the same year the Mac appeared.  X uses a client–server model.  An X server accepts client requests for graphical output (windows) and sends back user input (from keyboard, mouse, or touchscreen).

2. **Window manager**.  Requires X windows.  Puts the window decoration around the contents including the buttons to minimize or close. It allows resizing and moving the windows around, and decides which window is on top.



*   Enlightenment
*   Gala
*   Mutter
*   kwinx
*   i3
*   Joe's Window Manager (JWM)
*   Window Maker
*   IceWM
*   Afterstep
*   FVWW
*   Fluxbox
*   TWM
*   Megacity
*   Compiz

3. **Desktop environment**.  Requires a window manager.  Gives you an overall user experience. It has the panels, the system menus, the starters, the status applets. It might offer a default file explorer and viewer. It might contain a default editor, terminal program, and emailer, all made to look alike and work together.



*   Gnome - GNU Network Object Model Environment
*   KDE -  K Desktop Environment, now renamed Plasma
*   Pantheon
*   MATE - a fork of Gnome 2
*   Cinnamon
*   Ubuntu Budgie
*   Xfce

Gnome 2 used Metacity, which has been abandoned in favor of Mutter

Gnome 3 uses Mutter, which began as a fork of Metacity

Gnome 3 Shell is a Metacity plugin

Not everyone is happy with Gnome 3, because it lost many good features of Gnome 2.

Linus Torvalds used Gnome 2, then Xfce, then KDE, and as of 2013 back to Gnome 3 with extensions, particularly [Frippery](https://github.com/wangyr/gnome-shell-extensions/tree/master/Bottom_Panel@rmy.pobox.com/gnome-shell-frippery), and the [Gnome Tweak Tool](https://launchpad.net/gnome-tweak-tool).

Ubuntu uses Gnome 3 by default.

Kubuntu is Ubuntu with KDE

Neon is also Ubuntu with KDE


# The Human Interface


## from teletype to chat

type at a distance

telegraph system with a modified electric typewriter replacing the morse code key


## Full-Screen Interactive


```
top
info
man

vi
emacs
gedit ?
ed

line editors
full screen visual editors

ls 
```



# daemon

Daemon is a concept, not a specific thing in Linux.

A daemon is:



*   a process
*   running in the background
*   not associated with a terminal
*   requires no human interaction
*   started during startup
*   runs until shutdown
*   often named with an ending letter “d”

Examples:



*   sshd
*   httpd
*   crond
*   snapd
*   cryptd 

List all running daemons:


##### $ ps -C "$(xlsclients | cut -d' ' -f3 | paste - -s -d ',')" --ppid 2 --pid 2 --deselect -o tty,uid,pid,ppid,args | grep ^?

[https://unix.stackexchange.com/questions/175380/how-to-list-all-running-daemons](https://unix.stackexchange.com/questions/175380/how-to-list-all-running-daemons)


## daemon vs demon

Option one, they are equivalent.

	daemon == demon, pronounce both as “dee-mon”.

Option two, they are different.

	daemon = minor deity in ancient Greek mythology, pronounced as “day-mon”.

demon = evil spirit in Christian lore.

Regardless of spelling, pronunciation, and whether good or evil, it is conceptually an invisible, ever-present agent doing stuff in the background.

It has been claimed that one inspiration for the concept in operating systems came from “Maxwell’s demon”, described by physicist James Maxwell in 1867, a demon that enforces the second law of thermodynamics.

In Linux, it is spelled with an a, and most geeks pronounce it “day-mon”.


## daemon vs server

Many daemons are servers, and most servers run as daemons.



*   daemon - refers to the process, and the way it is running.
*   server - refers to how the program functions as a component in a client-server architecture.

For example, I could run a server program from my terminal during development and testing, and then put it into production by setting it up to be started automatically at boot and run in the background.  Only in the second case is the server running as a daemon.


## daemon vs service

Windows uses “service” to mean a daemon.

The word “service” can be used generally to refer to that which is provided by a server.

systemd now uses the term “service” to refer to a collection of resources, often including one or more daemons.

service is a linux system command, part of init or systemd-init, that can be used to run start and stop init scripts


##### $ type service


##### service is hashed (/usr/sbin/service)

service, newer idea, a collection of daemons

init

System configuration

Service bootstrap


# init

init - the original from SystemV Unix, serial-processing, slow boots

upstart - ubuntu-developed more efficient init

openrc - dependency-based, combines aspects of init and systemd

runit - cross-platform: BSD, MacOS, etc

systemd - multi-processing for fast boot, now ubiquitous

note: gentoo has its own init system

As of 2020, init has been replaced by systemd.  See below.


# systemd

launchd, introduced in macOS replaced initd, crond, and many others.  Services are started when needed and not all at boot.  Makes boot faster.

systemd is a rip-off of launchd, author Lennart Poettering

Startup mechanism

From bootstrap to service handling

From service manager to system manager

systemd started as init system and spiraled out

Daemons are userspace

System level, between kernel and userspace

Despite the controversy, systemd was adopted widely between 2011 and 2015


## Controversy over systemd

Source: [https://www.youtube.com/watch?v=o_AIw9bGogo](https://www.youtube.com/watch?v=o_AIw9bGogo)

Complaints



*   Violates unix philosophy.  What should be separate modules are all folded into one project, making it bloated and monolithic.
    *   Response: It is still made up of separate binaries.
*   Lennart Poettering manages the systemd project and he is a jerk

Pros



*   journald
*   cgroups, compared as superior to FreeBSD Jails
*   user-level units, running a daemon as a user instead of root, drop it into a folder and it starts
*   Message Transport, heavy use of dbus
*   RPC Framework, remote procedure call
*   Service Lifecycle
*   Automation via API
*   Containers, made possible by cgroups
*   The system layer, between kernel and user
*   Consistent device naming
*   Better log/event/audit handling, binary is ok
*   A new model of an application, multiple executables in a container

Notes:



*   Examples of New ways of thinking:  (not systemd specific)
    *   web api’s
    *   containers
*   Debian can run on FreeBSD kernel
*   Debian was reluctant to adopt systemd


## systemd service

sudo service gdm stop  # gdm = Gnome Desktop Manager

sudo service gdm start


## Components

init

logind

journald - writes to binary files (controversial)

udev - managing virtual device files

task scheduler - ala cron 

networkd - 

systemctl

hostnamectl

timedatectl

What is:

cgroups

dbus


##### $ ps -e | grep systemd


#####       1 ?        00:01:18 systemd


#####     309 ?        00:00:00 systemd-journal


#####     342 ?        00:00:01 systemd-udevd


#####     725 ?        00:00:01 systemd-resolve


#####     727 ?        00:00:00 systemd-timesyn


#####     809 ?        00:00:06 systemd-logind


#####    1448 ?        00:00:00 systemd

====== Notes ======
Multi-processing

multiple cores

Process/Thread per CPU
  $ ps -e | grep migration
  $ ps -e | grep ksoftirq
  $ ps -e | grep cpuhp
  $ ps -e | grep idle_inject
  $ ps -e | grep kworker (multiple per cpu)

kernel stack running at ring 0

each process has two stacks
user space stack
kernel space stack

separation: if the user stack is corrupted, we don’t want the kernel clobbered


